---
layout: post
title: "SE, 4장 Process Model"
description: "SE, 홍장의 교수님"
categories: [Software_Engineering]
tags: [2021-2, SE, Software Engineering, 홍장의]
use_math: true
redirect_from:
  - /2021/10/04/
---

* Kramdown table of contents
{:toc .toc}    


# Software Process Model

`Represent these several paths for developing software`

> 소프트웨어 제품을 구축, 제공, 배포 및 발전시키기 위해 따르는 프로세스
> 아이디어부터 시스템 배포 및 최종 폐기 까지의 과정

#### Goal of Production Process

고객의 기대 충족을 위해
- 양질의 제품을 예산 범위 내에서 제때 공급하며
- 제품을 수익성(profitable) 있게 만들고,
- 신뢰성(reliable), 예측가능성(predictable), 효율화(efficient)를 통한 생산

#### Software Life-Cycle Model

- Requirements
- Analysis
- Design
- Coding
- Testing
- Delivery
- Operations and Maintenance
- Retirement

## Why Process Models Important?

- 출시 시간 단축 및 생산 비용 절감
- 프로세스는 제품의 품질에 결정적인 영향을 미친다
- 프로세스를 제어함으로써 제품의 요구되는 품질까지 더 잘 도달할 수 있다

## Process

> A series of related steps for what to do

- 타당성 조사 (Feasibility Study)
- REQ 도출, 이해 및 구체화 (Eliciting, Understanding and Specifying REQs)
- 소프트웨어 아키텍쳐 및 상세 설계 (Software Architecture and Detailed design)
- 코딩 및 모듈 테스트 (Coding and Module testing)
- 통합 및 시스템 테스트 (Integration and System testing)
- 제공, 배포 및 유지 관리 (Delivery, Deployment And Maintenance)

## 프로세스 모델의 종류

> 프로세스 내에서 구성될 수 있는 방법에 대한 소프트웨어 개발 활동 표현들

- Build and Fix Model
- Waterfall Model
- Evolutionary Model
- Rapid prototyping
- Indremental
- Transformatio Model
- Spiral Model
- Others

### Build and Fix Model

> software is developed without any specification or design

- 주로 1인 작업
- 설명서나 설계 없이 개발이 됨
- 오늘날의 개발 환경에는 적합하지 않음
    - 컴퓨터 배경지식이 없는 사람들을 위해 개발됨
    - 보다 엄격한 신뢰성 요구 사항이 생겼고
    - 그룹 활동을 위주로 하기에

![image](https://user-images.githubusercontent.com/32366711/137317842-f11e0b93-65c3-498b-8c29-4aea16e4348c.png){: width="600"}{: .aligncenter}

### Waterfall Model

> Sequential, Phase-based, and Document-oriented

- 1970년대 이후 대중화됨
- 순차적, 단계 기반 및 문서 지향적
- 한단계의 출력이 다음 단계로의 입력으로 구성
- 제품의 구현은 그 목적이 충분히 파악된 후까지 연기해야 함


요구사항이 변경되었을 때 변경하기 어려움
단계 내에서 진행 상황을 측정하는 것은 어려움
이에 장기적/지속적인 프로젝트에 대해 열악함

![image](https://user-images.githubusercontent.com/32366711/137320415-e8681aa1-0717-44bc-a4e6-389feca62863.png){: width="600"}{: .aligncenter}


### Evolutinary Model

> Model whose stages consist of expanding the increments of operational software product


- 유지보수가 라이프 사이클의 단계에서 사라짐

#### 개발 전략

- Deliver, 배포
    - something to the real user
- Measure, 측정
  - the added value to the user in all critical dimensions
- Adjust
  - both the design and the objectives based on observed realities

#### type of evolutionary model

- Incremental approach
- Prototyping

### Incremental approach

> Stepwise development
> 각 단계에서 폭포수 모델에 의해 도입된 규칙들을 유지해야함 : 미니 폭포수 모델 프로세스

- 사용자에게 신제품에 적응할 수 있는 시간을 제공
- 변화를 수용하기에 편함
- 단계별 배포에 큰 비용이 요구되지 않음

but
- build-and-fix model과 유사함
- 통합 및 테스트마다 오버헤드해야함
- 부분적인 시스템이 사용자에게 최종시스템으로 여겨질수있다

![image](https://user-images.githubusercontent.com/32366711/137323237-326932ea-3f2f-48ab-a9c8-3c78abdf1930.png){: width="600"}{: .aligncenter}

### Prototype

> Do it Twice
> 점차 최종 시스템으로 진화할 수 있음

First version
- 제품의 타당성 평가와 요구사항 검증을 위한 시제품 (폐기될 예정)

Second version
- 폭포수 모델에 따라 개발

- 비용 및 시간 절감 가능
- 개발자,사용자간 상호작용 개선
- 오류를 조기에 찾을 수 있음
- 변화를 예상하는데 신경을 덜 쓸 수 있음

![image](https://user-images.githubusercontent.com/32366711/137324996-1f5e0d18-1628-4aab-b178-5ed3663bb5f2.png){: width="600"}{: .aligncenter}

### Rapid Application Development

> now often the most important requirement for software systems

비지니스의 요구사항은 빠르게 변하고 있는데, 일련의 안정적인 소프트웨어 요구사항을 생성하는 것은 불가능

이에 소프트웨어도 빠르게 진화해야 함

- 규격, 설계 및 구현이 상호적용됨
- 시스템은 버젼 평가에 관련된 이해 관계자와 함께 일련의 버젼으로 개발함
- 사용자 인터페이스는 IDE 및 그래픽을 사용하여 개발함

이후 애자일로 변환

### Agile Methods

- Dynamic System Development Method (Dane Faulkner and others)
- Adaptive Software Development (Jim Highsmith)
- Crystal Clear (a family of methods, Alistair Cockburn)
- XP (Kent Beck, Eric Gamma, and others)
- Scrum (Ken Schwaber, Jeff Sutherland, Mark Beedle)
- Lean Software Development (Mary and Tom Poppendieck)
- Feature-Driven Development (Peter Coad and Jeff DeLuca)
- Agile Unified Process (Scott Ambler)

#### XP Process

> 1990년대 Kent BEck의 eXtreme 프로그래밍 접근법                     
> 요구사항 변경을 다루는데 사용

Programmer 
- 분석, 설계, 테스트, 코딩, 통합

Manager
- 프로젝트 진행사항 관리

Customer
- 요구사항 및 우선순위 설정

**4 values**

- Communication
- Simplicity
- Feedback
- Courage

**12 Practices in XP**

- Planning process
- Small release
- Metaphor
- Simple design
- Continuous testing
- Refactoring
- Pair programming
- Collective code ownership
- Continuous integration 
- 40 hour week
- On-site customer
- Coding standard 

![image](https://user-images.githubusercontent.com/32366711/137328225-dc193d38-02b9-4916-a3d6-1f8b97bc5499.png){: width="600"}{: .aligncenter}


#### Scrum

> 구체적인 변화 보다는 반복적인 개발 관리
> Jeff Sutherland and Ken Schwaber

- 피드백 중심의 경험적 접근법
    - 모든 경험적 프로세스 제어와 마찬가지로 투명성, 검사 및 적응의 세 축에 의해 뒷받침됨 
- Scrum 프레임워크 내의 모든 작업은 결과를 책임지는 사람들에게 보여야 함
    - 프로세스, 워크플로우, 진행 등등
- Scrum 팀은 이러한 것들을 가시화하기 위해 개발 중인 제품과 팀의 작업실태를 수시로 점검해야 함

**3 Phases in Scrum**

- 초기 단계 : 개요 계획 단계
    - 프로젝트의 일반적인 목표를 설정하고 소프트웨어 아키텍처를 설계
- 중간 단계 : 일련의 스프린트 사이클이 뒤따르며, 각 사이클은 시스템의 증분을 발생
- 종료 단계 : 프로젝트 마무리
    - 시스템 도움말 프레임 및 사용자 매뉴얼과 같은 필수 문서를 작성하고, 프로젝트에서 얻은 교훈을 평가함

![image](https://user-images.githubusercontent.com/32366711/137331707-96f8c104-2f98-47ec-85ee-889fd1ccb0a6.png){: width="600"}{: .aligncenter}



**아티팩트**

- Product Backlog
    - 스크럼 팀이 제품에 대해 유지 관리하는 요구사항의 순서 목록
- Sprint Backlog
    - 개발팀이 다음 스프린트 기간 동안 다루어야 할 작업 목록
- Prouct Increment(orPotentially shippable increment, PSI)
    - 스프린트 기간 동안 완료된 모든 제품 백로그 항목의 합으로, 이전의 모든 스프린트의 작업과 통합됨
- Burn-Down Chart
    - 스프린트 백로그에 남아 있는 작업을 보여주는 공개 표시된 도표로, 매일 업데이트됨
    - Burn-Up Chart : 발매에 대한 트랙 진행 상황을 제공하는 방법

![image](https://user-images.githubusercontent.com/32366711/137331554-4e811362-94ca-4daa-9758-3bb068dc9a22.png){: width="600"}{: .aligncenter}



### Transformation Model

> Based on formal Specification             
> Viewed as a sequence of steps that gradually transform a spec into an implementation

- Manually and automatically
- 연구 지향적 접근 방식
- 프로그램 정확성 증명에 사용

- 전문지식이 필요
- 산업용으로 사용하기에 좁음

![image](https://user-images.githubusercontent.com/32366711/137331786-20d5ca0f-0cc7-4fc2-b542-621d0e19d7f5.png){: width="600"}{: .aligncenter}



### Spiral Model

> By B.Boehm
> 메타 모델

- 프레임워크 제공
- 현재 프로젝트의 리스크 레벨에 따라 가이드를 제시함
- 신중한 프로세스 설계를 통해 고위험 문제를 식별하고 제거하는데 집중

- 나선형 리크그 분석으로인해 비용이 많이 들 수 있음
- 적용범위가 제한적임
- 대규모 소프트웨어 개발 전용

![image](https://user-images.githubusercontent.com/32366711/137350978-b98524ef-e867-4342-81e6-4794ed6f4a05.png){: width="600"}{: .aligncenter}



### V Model

> 검증 모델
> 폭포수 모델의 확장 및 각 개발 단계에 대한 시험 단계의 연관성에 기초

- 고도로 훈련된 모델과 단계를 하나씩 완료
- 요구사항이 잘 파악된 소규모 프로젝트에 적합함
- 간단하고 이해하기 쉬움

- 요구사항의 변경 위험이 중간 이상 높은 사업에는 비적합
- 복잡하고 객체지향적인 사업에 비적합


![image](https://user-images.githubusercontent.com/32366711/137351298-d783ba80-06ee-4d36-b981-5d6c82d6b74b.png){: width="600"}{: .aligncenter}



### CBSE Process

> 구성요소 기반 소프트웨어 엔지니얼이 프로세스
> 1968, Doublas Mcllrooy

- 소프트웨어 구성요소의 현대적 개념 Brad Cox, 1986
    - Software ICs

![image](https://user-images.githubusercontent.com/32366711/137351609-a47b16f2-1176-4ccf-abc0-28d6ea77aa76.png){: width="600"}{: .aligncenter}


# DevOps






소프트웨어 수명주기 모델
require요구사항 analysis 분석 design 설계 coding 코딩 ( (시험) delivery 전달 
운영 및 유지관리 retire 은퇴

p43 소프트웨어 프로세스의 표준들

하늘색부분은 소프트웨어 개발에 따른 프로세스 표준
나머지부분은 그조직의 소프트웨어 프로세스를 얼마나 잘 적용하고 있는지 평가모델

1679, 498 ... 미국에서 나온 표준

아주오래전부터 제시가되어서 샤옹되었고, 가장 대표적인건 498이다

그중 12207 도 대표적, 지금사용

ISO 9000, CMMI, 15504는 알아둘필요성이 있다

ISO9000는 인증, 잘 개발하고 있구나라는 인증 


소프트웨어 개발성숙도 평가모델

SPICE Software Process Improvement and Capability dEtermination

CMMI는 15504보다 더유명. 능력 성숙도 통합 모델(Capability Maturity Model Integration

둘다 국제인증, international

CMMI lev 5

표준부터시작해서 분석설계서부터 해서 목차가 무엇이고 그 문서의 어떤 내용을 담아야 한다라는ㄱ ㅓㅅ이 498에서 시작, 이후 반영

IEEE Stds : 버전 관리를 어떻게 할것인가

그런것을모두 합쳐서 IEEE/EIA

12207
전체 수명주기에 대해서 틀을 제공해준다
이런걸 다 포함한 포괄적이다

모듈화를 가지고 쪼갰음 - 프로세스의 관점

이를 PDCA룰로 또 세부적으로 나눔 plan–do–check–act, Deming circle/cycle/wheel, Shewhart cycle, control circle/cycle, plan–do–study–act

각각의 태스크들을 찾아보고, 뭐를 점검해야하는지 이 룰에 따라서 정리한 것

실제로 1956에 나온 1207의 스탠다드를 보면 다음과 같다 
크게 3가지 프로세스 카탈로그

primary supporting, organizational

문서화는 어떻게 할 것인가, 형상관리 품질검증, 리뷰, 감사는 어떻게 할것인가 어던산출물을 만들것인가를 서포팅에서함

2017년 버전에서는 좀더 복잡하게 바뀜

Agreement, organizational project enabling, tee ... 로 나눔

강화했다

우리는 이 2017버젼으로 이해해야함

서브프로세스를 꼭 외워야할피요는없지만 알아는 두자

레거시 소프트웨어

현재 잘 사용되어지는 소프트웨어

그냥 쓰면 괜찮은데 기능을 더 보완하고 업그레이드할때는 문제

버리기아까운 레거시소프트웨어를 기반으로 새로운 소프트웨어로 업그레잊/버젼ㅇㅂ을 하기위해

역공학, REENgineering

레거시소프트웨어 + 알파의 새로운 코드로 소프트웨어를개발하려할때

레거시소프트웨어의 특징은 아주오랫동안사용했기에 잘돌아가기는 하지만 분석서 와의 일관성이 깨짐.

버그가났다면 코드만고치는경우가 많으니까

문서들이 사용불가능하기때문에 코드만 가지고 소프트웨어가 어떻게 구조화되어있음을 알 수없음

이 코드에서 기술정보를 가지고와서 리버스엔지니어링이라 부름, 리팩토링

역공학 = 재공학 + 순공학

코드를보면 call시퀀스를 볼수는있찌만 한눈에 볼수는없고 직접따라가야함

아상블 덕시젠 DoxyGen 은 코드를 넣어주면 콜그래프를 자동으로 생성해줌

이런걸 가지고 다시 소프트웨어를 개발, 순공학

우리는ㄴ 그닥 안할듯

프로세스모델이 왜 필요할까?

프로세스모델이라고하는게 스파이럴이라고하는게 나선형처엄돌아가는거고 에자일은 스프린트 사이클동안돌악면서 하는데, 그런게 없으면 어떻게될까

어쨋던 개발은 할텐데 제시해주면서 현제 어떤 상황에 놓여있는가
개발팀의 요구사항이 잘있는지, 능력은충분한지 상황을 알고 

 일들을 순서대로 따라가면다 무슨일을어떤순서대로 해야하는지 쉽게알수있음


메솔로지와의 차이점은?


what to do

무엇을 해야하는가만 정의하고있음


메솔로지 how to do

메솔로지관점은 객체지향설계때 했음









