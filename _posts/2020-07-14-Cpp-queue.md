---
layout: post
title: "C++ queue 사용법"
description: "C++ STL : queue"
categories: [C++]
tags: [STL, queue]
redirect_from:
  - /2020/07/14/
---
  <style>
    .small{
      font-size:12px;
    }
    .normal{
      font-size:12px;
      margin-left:15px;
    }
  </style>
* Kramdown table of contents
{:toc .toc}

> 선입 선출 (FIFO , First In First Out)

`#include <queue>` 필요

### 생성자
----------------
----------------
* `queue<[Data Type]> name`
* `queue<[Data Type],[Container Type]> name`
  - 내부 컨테이너를 바꿀 수 있음

### 멤버함수
----------------
----------------
* `q.push(x)` <span class="normal"> 가장 뒤에 x 삽입</span>
* `q.pop()` <span class="normal">가장 앞에 있는 원소 삭제<span>
* `q.front()` `q.back()`  <span class="normal">맨앞, 맨뒤 원소 참조</span>
* `q.empty()` <span class="normal">비었는지 확인, true == empty</span>
* `q.size()`  <span class="normal">원소 갯수 리턴, int </span>

* `q1.swap(q2)`  <span class="normal">queue 두개의 내용물 교환</span>

* `q.emplace()` <span class="normal"> 생성자를 호출해 컨테이너 내부에 객체를 바로 생성하고 큐의 끝에 추가한다.</span>
  - `push()`와`emplae()`의 차이점
  - <span class="small">push는 값의 복사본을 넣음<span>
  - <span class="small">emplace는 생성자를 호출해 새로 만들어서 넣음<span>
  - <span class="small">이런게 가능하다는 뜻<span>
  ~~~ c++  
  void main()
  {
      queue<pair<int, int> > q;
      for (int i=0; i<5; i++) {
          q.push(pair<int, int>(-i, i));
      }
  }
  ~~~
  ~~~ c++
  void main(){
      queue<pair<int, int> > q;
      for (int i=0; i<5; i++) {
          q.emplace(-i, i);
      }
  }
  ~~~