---
layout: post
title: "SE, 5장 Software Project Management"
description: "SE, 홍장의 교수님"
categories: [Software_Engineering]
tags: [2021-2, SE, Software Engineering, 홍장의]
use_math: true
redirect_from:
  - /2021/10/12/
---

* Kramdown table of contents
{:toc .toc}    


# Project Management

## Needs, 왜 필요할까

> 프로젝트 실패란 효율적이지못한 관리의 결과
> 지연, 신뢰성하락, 예산초과, 성능의 부족

이런일들이 발생하지 않도록 관리가 필요


## 다른 공학과의 차이점

인탠저블, 만질수없다

> 보이지않는 것들을 어떻게 관리할 것인지에 어려움이 있음
> SW process에 명확한 이해가 부족            
> Design intensive, 

소프트웨어가 개발프로세스를 가지는데 분석을 어떻게 할것인지

단계가 있고, 단계에 따라서 할 때 쉽게 추적할 수 있을텐데

분석은 그렇지 않음, Use-Case 다이어그램을 어떻게 그릴것인지 고민을 함

명확하게 이해되지 않을수 있음

경험이나 직관에 의거해서 진행하는 경우가 있을 수 있다

디자인 인텐시브하다        
- 사람에 의존적이다
- 사람의 노하우에 근거해서 실행, 사람이 하는 작업. 메뉴팩터링-인텐시브랑은 다름

## Most Importatnt Things

1 돈? 2 시간? 

`People, Smart People`

내가 메니지먼트에서 가져야할 유일한 규칙은 무엇일까
'나는 좋은 팀원들을 가지고 있다'라고 확신할 수 있는것


# Management Functions

> 관리 통제
> 개인으로 일하는 그룹이 일을 효과적, 효율적으로 하기 위해서 조직 내에서 내적인 환경을 생성하고 유지하는 것

내적 환경
- 장비부터 공간 시설, 휴게실도 환경이라고 볼 수 있음

가장 최적의 환경에서 일할 수있도록 만드는 것

## General functions of management

> 5가지 매니지먼트의 핵심 기능

Planing            
- 기준이 있어야하고, 그 기준은 다음과 같음
 
Organizing                   
- 팀을 구성하는 것
 
Staffing                     
- 분석팀 테스트팀 마케팅팀 어떠한 책임과 권한을 가질 것인가를 정의

Directing                      
- 각각의 세부적인 일들을 잘 하고 있는지 이끌어가는 디렉팅 과정

Controlling          
- 어떤 일들을 수행하는데 측정하고, 측정한 결과가 목표치에 도달하지 못했다면 뭘 바꿔야하는지 커렉팅액티비티를 수행


# Management Steps

![image](https://user-images.githubusercontent.com/32366711/137507051-11cd1db5-c6d6-490d-89ba-8e0dbdb40b55.png)


## Planning

`어떤 이슈를 계획하는가`

> 목표 이해 및 문서화  
             
- 소요자원 및 예산 결정
- 컴퓨터 자원의 수, 개발 인원 수 및 숙련도 파악 필요

얼마나 많은 개발자가 필요할 것인지, 이들의 생산성은 얼마인지 파악

= 예측, 소프트웨어 비용 산정


### Software Productivity

- 업무 난이도 추정
- 각 엔지니어의 능력(숙련도) 추정

쉬운일에 너무 비싼사람을 쓸 필요는 없음

엔지니어가 얼마나 많은 태스크를 해결할 수 있는가를 생각해야함

-> 결국 생산성

이 생산성을 얘기하는 **척도**는 무엇이 있을까

#### LOC

> 직관적으로 얘기하기 쉬움, 아주 일반적로 사용되어지는 생산력 표현법
> 언어에 따라서 상대적 특정을 해야한다

DSI :          
- 고객에게 배포된 코드의 라인수가 얼마냐
- 코드 라인 상에서 맨 마지막 번호가 몇인가만 봄(주석 포함)

NCSS :            
- 주석을 다 제거하고 딱 기능만


쉽고 직관적

그러나 활용, 실무적 적용면에선는 떨어짐

언어별로 표현력이 다르기 때문에 액면의 수치로 비교하기엔 적합하지 않음


### FP, Function Point

> 얼마나 큰 규모를 가지고 있는가, 시스템이 가지고있는 복잡도가 얼마인가를           
> $$<red>정량화</red> 하려는 시도


기능이 얼마나 있는지도 중요하지만, 각 기능이 가지고있는 복잡도도 얼마나 있는가도 중요한 요소

이걸 고려해 기능점수 산정

얼마나 오래 걸리는지,          
얼마나 많은 사람이 필요한지를 예측할 수 있음             

1차적으로보면 소프트웨어의 수와 복잡도를 산정 
이 점수가 결국 일정이라던지 사람으로 전환되서 해석될수있음 그런관점에서 얼마나 걸릴지를 결정할 수 있음

`생산성, 예산, 에러의 개수를 나타낼 수 있는 척도로서 사용`


처음엔 정보처리 추출 등 일반적인 전형적인 어플리케이션을 위해서 만들어짐

최근에는 보안되서 내장형 시스템에 대해서도 계산 가능


#### FP 산정 방법

`중요!`

![image](https://user-images.githubusercontent.com/32366711/137510069-9070891b-7bac-4356-bb68-e86f9637561d.png)

- Data Function = Internal Logical File + External Interface File
- Transaction Function = External Query + External Output + External Input

![image](https://user-images.githubusercontent.com/32366711/137510533-d71e5fee-4441-4d37-a98b-a60ba403530d.png)

1 Determine the type of Project

어떤 프로젝트 타입인가
처음부터 스크래치부터 개발하는 프로젝트인지, 업그레이드하는 프로젝트인지 
새 프로젝트, 유지 프로젝트, 보강 프로젝트 별로 다 계산 방법이 다름

2 Determine the scope of target System
 
 FP를 산정 하기 위한 범위 산정

전체에 대해서 다 산정할 수 있겠지만, 일반적으로 저금 출금 저축, 이체 등등 
기능이 이미 결정되어 있어서 FP가 이미 알려져있는거도 있음

또한 전체의 FP를 계산할 것인가 일부만 계산할 것인가         
만약 외주를 준다면 해당부분의 FP를 내서 외주 비용을 따로 계산하고                    
패키징을 구매한다하면 적정가는 얼마인지 계산하기 위해 FP를 내어야함               

이런걸 제외하고 계산하기도함

3 Identify data function & determine the complexity
4 Identify transacton function & determine the complexity

데이터펑션에 대해서도 식별을 하고, 복잡도가 얼마인지를 산정             
처리기능에 대해서 어떤것들이 있고, 어떤 복잡도가 있는지 산출                   

내부파일의 복잡도를  LOW, MID, HIGH 결정해야 하는데            
파일타입과 레코드타입으로 산정 해야함                       
얼마나 많은 파일에서 얼마나 많은 데이터를 참조하느냐에 따라 복잡도가 결정됨                     

또한 인풋 아웃풋 쿼리에 대해서 각각 복잡도를 계산해야 하는데          
인풋을 한다라고 하면, 인풋에 대한활동은 몇개의 데이터를 사용자가 입력하게 할것인가                  
데이터를 10개정도 입력한다, 사용자가 몇개의 화면에서 입력하는가 2개 MID                    
보고서를 출력하기위해 몇개의 파일에서 몇개의 데이터를 참조해야하는가                           


5 Procude the unadjusted FP

데이터와 처리가 다 식별이 되면 다 합쳐서(UFP)

6 Determine the Value adjust


내가 개발할 시스템이 얼마나 복잡한가를 결정

단순한 시스템이면 낮은 값으로, 복잡한 시스템이면 높은값

각 항목의 Degree정도를 구해서 모두다 더함 (TDI) 

여기에 0.01을 곱하고 +0.65를 해서 조정인자, VAF를 구함

7 최종적으로 조정해서 FP값을 내줌

5번에서 구한 UAF에 VAF를 곱해서 AFP, 최종 FP를 도축


![image](https://user-images.githubusercontent.com/32366711/137515206-8e42d138-e9db-48b6-98b8-a404141a817d.png)

![image](https://user-images.githubusercontent.com/32366711/137515270-df32f173-ea28-48bb-b7cb-f0f7a418acf0.png)

![image](https://user-images.githubusercontent.com/32366711/137515300-a148d3a6-6b2d-4c45-ba37-8275314e5825.png)


그럼 이게 얼마만큼의 규모를 가지는 것일까

C언어 기준으로 1FP에 132줄


| Imple. Languages       | # Lines   | Imple. Languages | # Lines |
|:----------------------:|:---------:|:----------------:|:-------:|
| Assembly Basic / Macro | 320 / 213 | FORTRAN          | 107     |
| BASIC                  | 107       | HTML 3.0         | 15      |
| Visual Basic           | 29        | LISP             | 64      |
| C                      | 132       | JAVA             | 53      |
| C++                    | 53        | PL/I             | 80      |
| COBOL                  | 107       | SQL              | 13      |
| DELPHI                 | 29        | Power Builder    | 16      |



### Other Factors Affecting Productivity
 
> 생산성에 미치는 다른 요소
> FP는 전체 프로젝트라기 보단 개발 대상 소프트웨어 자체
> 거기에 이제 이런 여러가지 팩터들을 고려해야함

- 사람에 대한 정보
- 제품의 복잡성
- 신뢰성(고장여부)
- 응답시간
- 언어 경험
- 일정의 제약사항 

등등

# Techniques of Software Cost Estimation

- 알고리즘 비용 모델링
    - 코코모
- 전문가의 판단
- 유사 프로젝트로 추정
- 파킨슨의 법칙
    - 가용 자원으로 결정
- 탑다운 추정
    - 전체 프로젝트를 먼저 추정하고 개별 작업을 할당
    - 계속 쪼개가며 리프노드에 도달했을 때, 이건 심플하고 단순하니까 개발비용을 각각 산정해서 섬업해서 측정
- 바텀업 추정
    - 개별 작업이 먼저 추정되고 전체 프로젝트 추정
    - 클래스 단위를 먼저 도출해서 이걸 구현하기위해 시간비용이 얼마일까를 합쳐서 전체적으로 얼마일까 

## COCOMO

> COnstructive COst MOdel              
> Based on the Delivered Source Instructions(DSI, KDSI)

계산모델이있는데 이게 액면 비용이 얼마이고 시간은 얼마인지

세가지 모델을 기반으로 계산             
`오가닉보다는 임베디드가 더 복잡하다`

| Development Mode | Nominal effort         | Schedule                    |
|:----------------:|:----------------------:|:---------------------------:|
| Organic          | $PM = 2.4(KDSI)^{1.05}$|$TDEV = 2.5({PM_{DEV}}^0.38)$|
| Semidetached     | $PM = 3.0(KDSI)^{1.12}$|$TDEV = 2.5({PM_{DEV}}^0.35)$|
| Embedded         | $PM = 3.6(KDSI)^{1.20}$|$TDEV = 2.5({PM_{DEV}}^0.32)$|

$\text{PM} = \text{Person-Month}$           
$\text{PM}_ {DEV} = \text{PM} * \text{Effort multiplier}$                 
$\text{TDEV} = \text{Months required to complete the project}$               

$ \text{PM}_ {DEV} / \text{TDEV} = \text{# of required persons}$

$ \text{Effort Multiplier} = \prod_ {i=1}^{15} \text{D}_ i $

노력승수는 15개의 항목으로 되어있음

![image](https://user-images.githubusercontent.com/32366711/137526086-8ee40683-7d95-4323-ab12-ec0143781ae1.png)

파라미터를 선택하고 조정하여 소프트웨어 비용을 분석할수 있어서 융통성은 있으나

코코모 1은 LOC를 기반으로해서 실용성이 떨어짐


코코모1은 폭포수모델을 베이스로 비용을 산정했다면
코코모2는 여러 모델의 비용산정을 가능케함

1은 KDSI를 기반으로 했지만, 2는 소스코드 + FP를 포함해서 비용산정

## COCOMO 2

> 프로젝트가 얼만큼 진행되었는가에 따라 서로 다른 모델을 사용하게함

코코모1이 단순히 3가지 모델에 대해서 공식에 따라 계산해다면,               
코코모2는 구체적인 산정 방법에 대해서는 제시하지 않았지만, 모델을 제시함으로써 유용성이 있음                   

|      | Step 1 | Step 2 | Step 3 |
|:----:|:------:|:------:|:------:|
| When | Prototyping phase | Preliminary | Post architexture |
| Metrics | App. point | FP | FP & LOC |
| Reuse | Implicit | Explicit | Explicit |
| Req. Changes | Implicit | One of Cost Drivers | One of Cost Drivers |

Application Point : # of components, # of screens in input / output interface


#### 1. 프로토타입 단계

> App point로 산정                  
> 구현하려는 화면의 갯수 스크린의개수, 인터페이스의 개수, 화면개수 그룹섹션의 개수로 산정하는 기법              

이때 재사용이나 변경은
implict, 반영되어있다하고 추가적으로 계산하지 않는다
 
#### 2. 기본설계 단계

> FP로 계산
> 요구사항분석이 완료되었기때문에 FP를 산정하기 위한 데이터도출완료
 
제사용을 하는건 명확하게 고려해서 FP 산정에 반영하겠다               
묵시적고려X 별도고려               

요구사항 변경도 비용 유발의 한 요소

#### 3. 아키텍쳐의 구현 이후

> 상세 설계를 하고, 구현을 함
> FP 와 LOC도 사용

재사용 명확하게 계산 반영
요구사항변경도 비용인자로서 고려

# Project Control

> 프로젝트가 얼마나 진행되는가 모니터링 하는 방법

계획들이 프로젝트가 시작되서 진행되는 과정에서 진도체크를 하기위한 수단

실제 수행하면서 편차, 딜레이가 발생하는지에 대해

검사할 수 있는 방법으로도 사용

**프로젝트 컨트롤 기술**

- Work Breakdown Structure (WBS)
- Gantt Chart
- PERT chart(program evaluation & review technique)

## WBS, Work Breakdown Structure

> 프로젝트를 여러 중간 목표로 세분화함           
> 프로젝트가 수행해야 하는 모든 활동을 파악하기 위함

분석, 설계, 코딩, 테스팅, 메뉴얼 작성 등으로 구성

프로젝트가 진행되는 과정에서 수행되는 모든 과정을 계층구조의 트리형태로 만들어서 식별

이 트리의 최상단, 루트는 프로젝트 이름이 될 수도있고, 핵심 골이 될 수 있음
이걸 작은 컴포넌트로 브렉다운, 그럼 언제까지 쪼갤것이냐

리프까지. 리프 노드에 존재하는 액티비티가 크기, 난이도, 자원에서 확신, 평가할 수 있을 때 까지

가급적이면 독립적인 작은 단위의 활동으로 표현하면 어느정도 규모다라는것을 예측할수있음

사이즈나 복잡도를 알게되면 얼만큼의 시간이 걸리고, 이루어질 수 있겠다를 판단할 수 있음


# 27 간테차트 12:36


간테차트는 바차트형태, 기간 일정이 주어지고 일정동안에 바라고 하는 것을 얼마만큼의 일들이 이루어진다를 표현하는 것

퍼트차는 조금 다른데, 각각의 일들이 어떠한 순서를 가지고 진행되는가를 나타내고있음

각각의 작업들은 얼마만큼의 시간이 걸려서 진행이 되는가





