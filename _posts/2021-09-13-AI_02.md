---
layout: post
title: "AI, 2장 탐색과 최적화"
description: "AI, 이건명 교수님"
categories: [AI]
tags: [2021-2, AI, Artificial Intelligence, 이건명]
use_math: true
redirect_from:
  - /2021/09/06/
---

* Kramdown table of contents
{:toc .toc}      


# 탐색

## 상태 공간과 탐색

#### 탐색, search

> <blue>문제의 해(solution)[^solution]</blue>이 될 수 있는 것들의 <blue>집합</blue>을 <red>공간(space)</red>로 간주하고          
> 문제에 대한 <blue>최적의 해</blue>를 찾기 위해 <red>공간을 체계적으로 찾아 보는 것</red>               

#### 상태, state

> 특정 시점에 문제의 세계가 처해있는 모습

#### 세계, world

> 문제에 포함된 대상들과 이들의 상황을 포괄적으로 지칭

#### 상태 공간, state space

> 문제 해결 과정에서 초기 상태로부터 도달할 수 있는 <red>모든 상태들의 집합</red>           
> 문제의 해가 될 가능성이 있는 모든 상태들의 집합 

- 초기상태(initial state) : 문제가 주어진 시점의 시작 상태          
- 목표 상태(goal state) : 문제에서 원하는 최종 상태          

#### 상태 공간 그래프, state space graph

> 상태 공간에서 각 행동에 따른 상태의 변화를 나타낸 그래프

- 노드 : 상태
- 링크(엣지) : 행동

`일반적인 문제에서는 상태 공간이 매우 큼 -> 탐색 과정에서 그래프 생성`


![image](https://user-images.githubusercontent.com/32366711/134811678-4d87bc76-aee7-45d4-a44d-694df462b6bb.png){: width="300"}{: .center}


## 맹목적 탐색

> <red>정해진 순서</red>에 따라 상태 공간 그래프를 점진적으로 생성해 가면서 해를 탐색하는 방법

### 깊이 우선 탐색, Depth-First Search

방문한 노드는 재방문 하지 않음          
루트 노드에서 현재 노드까지의 경로 하나만 유지               

> 메모리 공간 사용이 효율적   
> 최단 경로 해의 탐색은 보장 불가                   

### 너비 우선 탐색, Breadth-First Search

모든 자식 노드를 확장하며 탐색           
전체 트리를 메모리에서 관리          

> 메모리 공간 사용 비효율           
> 최단 경로 해의 탐색을 보장함 

### 반복적 깊이 심화 탐색, Iterative-Deepening Search

깊이 한계가 있는 깊이 우선 탐색을 반복적으로 적용

> 최단 경로 해의 탐색을 보장                                   
> 메모리 공간 사용도 효율적        
> but, 반복적으로 깊이우선 탐색을 하다보니 시간적으로 비효율적                         
> 이지만, 실제로는 크게 늘지 않음[^iterative-deepening]                                                                

깊이 0에 대해 깊이 우선 탐색              
깊이 1에 대해 깊이 우선 탐색          
깊이 2, 깊이 3 ...                 
을 목표 상태를 찾을 때 까지 함                 


### 양방향 탐색, Bidirectional Search

초기 노드와 목적 노드에서 동시에 너비 우선 탐색을 진행          
반씩 나눠서 찾기에 깊이가 너비우선 탐색에 비해 반으로 줄음


## 정보이용 탐색

### 휴리스틱 탐색, Heuristic Search

> 그리스어 Εὑρίσκω (Eurisko, 찾다, 발견하다)         
> 시간이나 정보가 불충분하여 합리적인 판단을 할 수 없거나,          
> 굳이 체계적이고 합리적인 판단을 할 필요가 없는 상황에서 <red>신속하게 어림짐작 하는 것</red>

ex) 최단 경로 문제에서 목적지 까지 남은거리 == 지도상의 직선거리로 계산 (실제론 돌아갈지라도)

### 언덕 오르기 방법, Hill Climbing Method

> 지역 탐색 + 휴리스틱 탐색
> 현재 노드에서 휴리스틱에 의한 평가값이 가장 좋은 이웃 노드 하나를 확장해 가는 탐색 방법      

`국소 최적해`에 빠질 수 있음

![image](https://user-images.githubusercontent.com/32366711/134812658-7f881163-5cfa-4fe8-8adc-112527383d38.png){:width="250"}

### 최상 우선 탐색, Best-First Search

> 확장 중인 노드들 중에서 목표 노드까지 남은 거리가 <red>가장 짧은 노드를 확장</red>하여 탐색         
> 남은 거리를 정확히 모르니까 <blue>휴리스틱</blue> 사용

### 빔 탐색, Beam Search

> 휴리스틱에 의한 평가값이 우수한 <red>일정 개수의 확장 가능한 노드</red>만을        
> 메모리에 관리하면서 <red>최상 우선 탐색</red> 적용

### A* 알고리즘

> 추정한 전체 비용 $\hat f(n)$을 최소로 하는 노드를 확장해 가는 방법

- $f(n)$ : 노드 n을 경유하는 전체 비용
    - $f(n) = g(n) + h(n)$
    - 이미 투입된 비용 $g(n)
    - 목표까지 남은 비용 $h(n)$

- $h(n)$ : 남은 비용              
    - 정확한 예측 불가 -> 휴리스틱 함수 $\hat h(n)$ 사용

- $\hat f(n)$ : 노드 n을 경유하는 추정 전체 비용
    - $\textcolor{red}{\hat f(n) = g(n) + \hat h(n)}$

## 게임에서의 탐색

## 제약조건 만족 문제



# 최적화

## 목적함수

## 조합 최적화

## 함수 최적화



[^solution]: 일련의 동작으로 구성되거나 하나의 상태로 구성
[^iterative-deepening]: 자식당 10개의 자식 노드를 가질 때 약 11%정도 추가 노드를 생성함    
