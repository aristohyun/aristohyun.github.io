---
layout: post
title: "작성중 : C++, Tree"
description: "Data Structure"
categories: [C++]
tags: [Data Structure, Tree]
redirect_from:
  - /2020/07/28/
---

* Kramdown table of contents
{:toc .toc}

### 이진트리
#### 완전 이진트리
> 일반적인 이진트리
#### 이진 포화트리
> 모든 노드가 2개의 자식을 가지고 있고, 깊이도 같음
> 전체 노드의 갯수를 알 수 있음


#### 구현
~~~ c++
class Node{
public:
  int value;
  Node* left;
  Node* right;

  Node(){this->value = 0; this->left=nullptr; this->right=nullptr;} 
  Node(int _value){this->value = _value; this->left=nullptr; this->right=nullptr;}
  Node(int _value, Node* _left, Node* _right){this->value = _value; this->left=_left; this->right=_right;}
}
~~~

#### 순회    
##### inorder, 전위    
> now -> left -> right    

~~~ c++
void inorder(Node* now){
  if(now != null){
    now->value;
    inorder(T->left);
    inorder(T->right);
  }
}
~~~
##### postorder, 중위
> left -> now -> right    

~~~ c++
void postorder(Node* now){
  if(now != null){
    postorder(now->left);
    now->value;
    postorder(now->right);
  }
}
~~~
##### preorder, 후위
> left -> right -> now    

~~~ c++
void preorder(Node* now){
  if(now != null){
    preorder(now->left);
    preorder(now->right);
    now->value;
  }
}
~~~



### 전체

~~~ c++

class Node{
public:
  int value;
  Node* left;
  Node* right;

  Node(){this->value = 0; this->left=nullptr; this->right=nullptr;} 
  Node(int _value){this->value = _value; this->left=nullptr; this->right=nullptr;}
  Node(int _value, Node* _left, Node* _right){this->value = _value; this->left=_left; this->right=_right;}

  //탐색
  Node* search(int target){ 
    if(this->value == target) return this;

    Node* searchLeft = (this->left != nullptr) ? this->left->search(target) : nullptr;
    Node* searchRight = (this->right != nullptr) ? this->right->search(target) : nullptr;

    if(searchLeft != nullptr) return searchLeft;
    if(searchRight != nullptr) return searchRight;

    return nullptr;
  }
  //전위
  void inorder(){
    cout << this->value << endl;

    if(this->left != nullptr){
      this->left->inorder();
    }
    if(this->right != nullptr)
      this->right->inorder();
    }
  }
  //중위
  void postorder(){
    if(this->left != nullptr){
      this->left->inorder();
    }

    cout << this->value << endl;

    if(this->right != nullptr)
      this->right->inorder();
    }
  }
  //후위
  void preorder(){
    if(this->left != nullptr){
      this->left->inorder();
    }
    if(this->right != nullptr)
      this->right->inorder();
    }
    cout << this->value << endl;
  }
};

~~~