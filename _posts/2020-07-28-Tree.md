---
layout: post
title: "작성중 : C++, Tree"
description: "Data Structure"
categories: [C++]
tags: [Data Structure, Tree]
redirect_from:
  - /2020/07/28/
---

* Kramdown table of contents
{:toc .toc}

## 이진트리
#### 완전 이진트리
> 일반적인 이진트리
#### 이진 포화트리
> 모든 노드가 2개의 자식을 가지고 있고, 깊이도 같음
> 전체 노드의 갯수를 알 수 있음

### 구현
~~~ c++
class Node{
public:
  int value;
  Node* left;
  Node* right;

  Node(){this->value = 0; this->left=nullptr; this->right=nullptr;} 
  Node(int _value){this->value = _value; this->left=nullptr; this->right=nullptr;}
  Node(int _value, Node* _left, Node* _right){this->value = _value; this->left=_left; this->right=_right;}
}
~~~

### 순회    
#### inorder, 전위    
> now -> left -> right    

~~~ c++
void inorder(Node* now){
  if(now != null){
    now->value;
    inorder(T->left);
    inorder(T->right);
  }
}
~~~
#### postorder, 중위
> left -> now -> right    

~~~ c++
void postorder(Node* now){
  if(now != null){
    postorder(now->left);
    now->value;
    postorder(now->right);
  }
}
~~~
#### preorder, 후위
> left -> right -> now    

~~~ c++
void preorder(Node* now){
  if(now != null){
    preorder(now->left);
    preorder(now->right);
    now->value;
  }
}
~~~



### 전체

~~~ c++

class Node{
public:
  int value;
  Node* left;
  Node* right;

  Node(){this->value = 0; this->left=nullptr; this->right=nullptr;} 
  Node(int _value){this->value = _value; this->left=nullptr; this->right=nullptr;}
  Node(int _value, Node* _left, Node* _right){this->value = _value; this->left=_left; this->right=_right;}

  //탐색
  Node* search(int target){ 
    if(this->value == target) return this;

    Node* searchLeft = (this->left != nullptr) ? this->left->search(target) : nullptr;
    Node* searchRight = (this->right != nullptr) ? this->right->search(target) : nullptr;

    if(searchLeft != nullptr) return searchLeft;
    if(searchRight != nullptr) return searchRight;

    return nullptr;
  }
  //전위
  void inorder(){
    cout << this->value << endl;

    if(this->left != nullptr){
      this->left->inorder();
    }
    if(this->right != nullptr)
      this->right->inorder();
    }
  }
  //중위
  void postorder(){
    if(this->left != nullptr){
      this->left->inorder();
    }

    cout << this->value << endl;

    if(this->right != nullptr)
      this->right->inorder();
    }
  }
  //후위
  void preorder(){
    if(this->left != nullptr){
      this->left->inorder();
    }
    if(this->right != nullptr)
      this->right->inorder();
    }
    cout << this->value << endl;
  }
};
~~~


## 이진 탐색트리    
> Right Node는 Parent Node보다 큰 값을 가지며,    
> Left Node는 Parent Node보다 작은 값을 가지는 이진트리    
> 루트 보다 작은 값은 왼쪽 큰값은 오른쪽으로 정렬되어 있기에, 탐색에 용이함   

### 구현

~~~ c++
void push(int key){
  if(this->value > key){
    if(this->left == nullptr)  this->left = new Node(temp);
    else this->left->push(key);
  }else{
    if(this->right == nullptr)  this->right = new Node(temp);
    else this->right->push(key);
  }
}
Node* search(int key){
  if(this->value == key)  return this;
  else if(this->value > key)  this->left->search(key);
  else if(this->value < key)  this->right->search(key);
  
  return nullptr;
}
~~~