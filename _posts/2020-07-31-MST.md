---
layout: post
title: "작성중 : 최소비용 신장트리"
description: "Prim, Kruskal"
categories: [Algorithm]
tags: [Graph, MST, Prim, Kruskal]
redirect_from:
  - /2020/07/31/
---

* Kramdown table of contents
{:toc .toc}

## Prim

### 신장트리
> 신장트리(Spanning Tree)란, 그래프에서 일부 간선만을 연결해 만든 그래프로
> 최소 연결 부분 그래프이다.

### 최소 비용 신장 트리
> 최소 비용 신장 트리(MST: minimum spanning tree)란, 사용된 간선들의 가중치 합이 최소인 신장트리 말한다    

### Prim 알고리즘
> Prim알고리즘은 이 MST를 만드는 알고리즘으로,    
> 시작 정점에서부터 출발하여 신장 트리 집합을 단계적으로 확장해나가는 방법을 사용한다    
> 변의 개수를 E, 꼭짓점의 개수를 V라고 하면 이 알고리즘은 O(E logV)의 시간복잡도를 가진다
> 피보나치 힙을 이용하여 훨씬 빠르게 할 수 있다( O(E + V logV) )



### 구현
~~~ c++
/*
#define INF 10000;
class Graph{
public:
  vector<vector<int>> edge;
}
*/
typedef tuple<int,int,int> P;   //weight, from, to

Graph Prim(Graph graph){
  Graph primGraph(graph.edge.size());
  vector<bool> visited(graph.edge.size(),false);  visited[0]=true;
  priority_queue<P, vector<P>, greater<P>> pq;  //우선순위큐
    
  pushWeight(pq,0,graph,visited); //0과 연결된 노드 push

  while(!pq.empty()){
    int weight, from, to;
    tie(weight,from,to) = pq.top(); pq.pop(); //우선순위 큐이니 최소값이 return

    if(visited[to]) continue; //방문한 곳이면 패스
    else visited[to] = true;

    primGraph.setEdge(from,to,weight);  //최소값이니 그래프에 연결해줌

    pushWeight(pq,to,graph,visited); //to와 연결된 노드 push
  }

  return primGraph;
}

void pushWeight(priority_queue<P, vector<P>, greater<P>>& pq, int now ,Graph graph, vector<bool> visited){
  for(int i=0;i<graph.edge.size();i++){
    if(graph.edge[now][i] != INF && !visited[i]){
      pq.push(make_tuple(graph.edge[now][i],now,i));
    }
  }
}
~~~


## Kruskal
> MST를 만드는 가장 대표적인 알고리즘. 
> 변의 개수를 E, 꼭짓점의 개수를 V라고 하면 이 알고리즘은 O(E logV)의 시간복잡도를 가진다

### 구현
~~~ c++
/*
class Graph{
public:
  vector<vector<int>> edge;
}
*/
Graph Kruskal(Graph graph){
  Graph kruskalGraph;
  priority_queue<int,int,int> pq; //from, to, weight
  int size = graph.edge.size();
  vector<bool> visited(size,false);

  visited[0] = true;
  for(int i=0;i<size;i++){
    for(int j=i+1; j<size; j++){

    }
  }
//0. now = visited
//1. for(j=i+1;j<size()) //모든 노드 삽입
//    pq.push(edge[i][j])
//  
//2. now = pq.pop();
//3. result.push(now);
//4. go 0

  return kruskalGraph;
}
bool isVisited(){
  
}

~~~
