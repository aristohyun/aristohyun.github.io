---
layout: post
title: "DBS, 5. Relational Algebra & Relational Calculus"
description: "DBS, 이종연 교수님"
categories: [DBS]
tags: [2021-2, DBS, Database System, DBMS, 이종연]
use_math: true
redirect_from:
  - /2021/09/29/
---

* Kramdown table of contents
{:toc .toc}     

|| 관계 대수 <br/>  Relational Algebra | 관계 해석 <br/> Relational Calculus |
|:---:|:--------:|:---------:|
|특징| 절차적 언어 <br/> 순서 명시 | 비절차적 언어 <br/> 계산 수식의 유연적 사용 <br/>술어 해석[^Predicate_Calculus] 기반 |
|목적| 어떻게 유도하는가 <br/> How | 무엇을 얻을 것인가 <br/> What |
|종류| 순수 관계 연산자 <br/> 일반집합 연산자 | 튜플 관계 해석 <br/> 도메인 관계 해석 |

# 관계 대수, Relational Algebra

> 관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해서             
> $$<blue>어떻게</blue> 유도하는가를 기술하는 <red>절차적인 언어</red>                 

- 대수 연산은 새로운 관계를 생성하게 됨
- 수열의 관계 대수식을 형성함
    - 관계 대수식의 결과는 데이터베이스 쿼리의 결과를 나타내는 관계

#### 순수 관계 연산자

- Select $\;\;\; {\color{red} \sigma}$
    - 조건을 만족하는 튜플들의 <red>부분 집합</red>
    - 수평 연산
- Project $\;\;\; {\color{red} \pi}$
    - 속성들의 부분 집합, <red>중복은 제거됨</red>
    - 수직 연산
- Rename  $\;\;\; {\color{red} \rho}$
- Join $\;\;\; {\color{red} \bowtie}$
    - 두 릴레이션이 <red>공통</red>으로 가지고 있는 속성을 이용하여 두개의 릴레이션을 </ed>하나로 합쳐서</red> 새로운 릴레이션을 만드는 연산
    - 두개의 릴레이션의 연관된 튜플들을 결합
- Division $\;\;\; {\color{red} \div}$
    - R 릴레이션에서 S 릴레이션의 속성 도메인 값과 <red>일치</red>하는 R 릴레이션의 튜플들을 찾아내는 연산


#### 일반 집합 연산자

- Union $\;\;\; {\color{red} \cup}$
    - 두개의 릴레이션의 합이 추출되고 중복은 제거됨
- Intersection $\;\;\; {\color{red} \cap}$
    - R 릴레이션과 S 릴레이션의 중복되는 값들만 추출
- Difference $\;\;\; {\color{red} -}$
    - R 릴레이션에서 S 릴레이션에 중복되지 않는 값들만 추출
- Cartesian Product $\;\;\; {\color{red} \times}$
    - 두 릴레이션의 가능한 모든 튜플들의 집합
    - 차수(Degree)는 더하고, 집합(Cardinality)은 곱해서 구함


## 단항 관계 연산자, Unary Relational Operations

### Select

@
\sigma _ {\<selection condition\>} (R)
@

> 선택 조건을 기반으로 관계에서 튜플의 하위 집합을 선택하는 데 사용              
> 선택 조건이 필터 역할을 함

- 선택 조건은 R의 속성에 지정된 조건(Boolean) 식이여야 함
    - True인 값만 선택되고
    - False인 값은 필터링됨(제외)

- 교환 법칙 가능
    - $\sigma _ {\<cond_ 1 \>}(\sigma _ {\<cond_ 2 \>} (R)) == \sigma _ {\<cond_ 2 \>}(\sigma _ {\<cond_ 1 \>} (R))$
- 모든 조건이 결합된(AND) 단일 선택으로 대체 가능
    - $\sigma _ {\<cond_ 1 \>}(\sigma _ {\<cond_ 2 \>} (R)) == \sigma _ {\<cond_ 1 \> AND \<cond_ 2 \>} (R))$

#### Example

$
\sigma _ {DNO = 4}(EMPLOYEE) \\\ 
DNO4_EMPS \leftarrow \sigma _ {DNO = 4}(EMPLOYEE)
$

~~~ sql
SELECT * FROM Employee WHERE dno = 4;  
~~~
  
### Project

@
\pi _ {\<attribute list\>} (R)
@

> 특정 열(속성)을 제외한 다른 열을 삭제함 : 수직 분할             
> 해당 열에서 중복된 값이 있다면 제거하고 출력

- 교환 법칙 불가능
    - $\pi _ {\<list 1 \>}(\pi _ {\<list 2 \>} (R)) \neq \pi _ {\<list 2 \>}(\pi _ {\<list 1 \>} (R))$
    - list 1에서 중복 제거 -> 그중 list 2의 중복 제거와 반대는 다름
    
#### Example

$
\pi_ {NAME, SALARY}(\sigma_ {DNO=5}(EMPLOYEE)) \\\ 
 \\\ 
DNO5_ {EMPS} \leftarrow \sigma _ {DNO = 5}(EMPLOYEE) \\\ 
RESULT \leftarrow \pi _ {NAME, SALARY}(ENO5_ {EMPS})
$


### Rename

@
\rho_ S (R) \\\ 
\rho_ {(B_ 1, \cdots, B_ n)}(R) \\\ 
\rho_ {S(B_ 1, \cdots, B_ n)})(R) \\\ 
@

> Relation 이름이나, 속성의 이름을 바꿀 수 있음        

1. Relation name 을 S로 변경
2. 속성들의 값을 $B_ 1, \cdots, B_ n$으로 변경
3. 둘다 변경

> Combining 할 때, 종종 이름 충돌이 일어날 수 있음       
> 이는 유저와 DBA 모두에게 모호할 수 있어 명시적으로 이름을 바꾸는 것이 유용함

## 집합 연산자, Set Theory

> 같은 수의 속성과 도메인이 같아야만 가능                
> 속성 이름이 다를 경우, 일반적으로 앞의 피연산자의 속성 이름으로 함                     

`두 피연산자는 <red>Type Compatible</red>(Union Compatible) 되어야 한다`

### Union

@
R \cup S
@

> 이항 연산           
> R과 S에 있는 모든 튜플을 포함하는 관계      
> 중복인 튜플은 제거됨           

교환법칙 가능

#### Example 

$
DEP5_EMPS \leftarrow \sigma_ {DNO=5}(EMPLOYEE) \\\  
RESULT1 \leftarrow \pi_ {SSN}(DEP5_ EMPS) \\\ 
RESULT2(SSN) \leftarrow \pi_ {SUPERSSN}(DEPS_ EMPS) \\\ 
RESULT \leftarrow RESULT1 \cup RESULT2
$

### Intersection

@
R \cap S
@

> R과 S 모두 있는 튜플을 포함하는 관계        

교환 법칙 가능

### Set Difference

@
R - S
@

> Minus, Except           
> R에는 있지만, S에는 없는 튜플       

교환법칙 불가능

### Cartesian Prodruct

@
R \times S
@

> 카티션 프로덕트, 곱집합             
> 속성의 개수는 n + m 개        
> 튜플의 개수는 r * s개                        


일반적으로 의미있는 작업은 아님
- 다른 작업을 수행할 때 필요할 수 있음

#### Example

$
FEMALE_ EMPS \leftarrow \sigma_ {SEX='F'}(EMPLOYEE) \\\ 
EMPNAMES \leftarrow \pi_ {FNAME, LNAME, SSN}(FEMALE_ EMPS) \\\ 
EMP_ DEPENDENTS \leftarrow EMPNAMES \times DEPENDENT \\\ 
ACTUAL_ DEPS \leftarrow \sigma_ {SSN=ESSN}(EMP_ DEPENDENTS) \\\ 
RESULT \leftarrow \pi_ {FNAME, LNAME, DEPENDENT_ NAME}(ACTUAL_ DEPS)
$

1. EMPLOYEE에서 성별이 여자인 모든 튜플들을 FEMALE_ EMPS에 저장 
2. FEMALE_ EMPS에서 FNAME, LNAME, SSN만 추출해서 EMPNAMES에 저장         
3. EMPNAMES와 DEPENDENT의 모든 튜플들을 곱해서 EMP_ DEPENDENTS에 저장       
    - 여기까지는 필요 없는 정보, 잘못 연결된 값들도 있기에
4. SSN이랑 ESSN이랑 같은, 실제로 정확히 연결된 튜플들만 추출해서 ACTUAL_ DEPS에 저장        
5. ACTUAL_ DEPS에서 필요한 속성들(이름, 부양가족 이름)만 추출

RESULT는 최종적으로 여자 근로자의 이름과 부양가족들이 나열된다


## 이항 관계 연산자, Binary Relational Operations

### Join      

@
R \bowtie _ \<condition\> S
@

> 관련된 튜플을 결합할 수 있게 해줌        

위에서 곱집합으로 두 Relation을 연결하는 것은 굉장히 복잡한 과정을 거쳤지만,        
이를 Join으로 단일 연산으로 결합할 수 있음  

#### Example

$
RESULT \leftarrow EMPLOYEE \bowtie _ {SEX='f' AND SSN = ESSN} DEPENDENT
$

# 관계 해석, Relational Calculus

> 술어 해석에 기반을 두고 관계 데이터베이스를 위해 제안              
> 원하는 정보가 <blue>무엇</blue>이라는 것만 정의하는 <red>비절차적 특성</red>

- 관계 해석과 관계 대수는 데이터베이스를 처리하는 기능과 능력면에서 동등
- 관계대수로 표현한 식은 관계 해석으로 표현할 수 있음

#### 연산자

- OR $\;\;\; \vee$
- AND $\;\;\; \wedge$
- NOT $\;\;\; \neg$

#### 정량자

- 전칭 정량자 $\;\;\; \forall$
- 존재 정량자 $\;\;\; \exists$




[^Predicate_Calculus]: Predicate_Calculus
