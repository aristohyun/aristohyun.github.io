---
layout: post
title: "IP, 6장 공간기반 처리 LPF"
description: "영상처리, 최경주교수님"
categories: [ImageProcessing]
tags: [2022-1, Image Processing, IP, 최경주]
use_math: true
redirect_from:
  - /2022/04/14
---

* Kramdown table of contents
{:toc .toc} 

# Spatial Filtering

> 공간 주파수란, 단위 거리당 파동의 진동수     
> 즉 일반적인 사인파와 같이 일정한 주기를 갖는 파동이 단위길이당 반복되는 횟수를 말한다

- 상관(correlation)
    - 물체를 표현하는 윈도우 u 와 입력 영상 f 가 얼마나 비슷한지 측정해 주는 연산
    -  대표적인 영역 연산
    -  물체의 크기나 회전 변환이 없다고 가정
- 컨볼루션(convolution)
    - 윈도우를 뒤집은 후 상관 적용 -> 상관과 윈도우의 모양만 다름
    - 임펄스 반응 함수(impulse response function)에 그대로 반응

따라서 보통 둘을 구별하지 않고 `컨볼루션`이라는 용어를 사용, 윈도우는 마스크

## 컨볼루션 예제

![image](https://user-images.githubusercontent.com/32366711/164960422-7170056e-71f2-4c37-b1e1-2ced4354867c.png)


- 박스, 가우시안 : 스무딩 효과 (에버리지 필터)
- 샤프닝 : 명암 대비 강조 효과 (고주파 필터)
- 수평 에지, 수직 에지 : 에지 검출 효과

> 컨볼루션은 마스크 계수에 화소값을 곱하고 더하는 연산을 하는 선형 연산이다



- `저주파`는 명암도의 값이 차이가 없거나 `천천히` 변함
- `고주파`는 명암도의 값이 차이가 크거나 `급격히` 변함

그럼 고주파 필터는 저주파는 통과가 안됨

저주파 통과필터는 명암도가 높은 부분을 통과안시킴. 흐리게

## Low-Pass Filter

`저주파 통과 필터` == `고주파 차단 필터`

> 신호 성분 중 저주파 성분은 통과시키고 고주파 성분은 차단하는 필터로써 잡음을 없애거나 흐릿한 영상을 얻는데 주로 사용

- 평활화 또는 블러링(blurring)
- 모든 계수가 양수이고 전체 합이 1인 마스크 사용

> 작은 객체의 명암도는 배경과 혼합되고, 더 큰 객체는 쉽게 검출할 수 있게 해서,             
> 관심의 대상인 객체의 대체적인 표현을 얻을 목적으로 영상을 흐리게 함

@
\frac{1}{12} \times \begin{bmatrix}
1 & 1 & 1 \\\ 
1 & 4 & 1 \\\ 
1 & 1 & 1 \\\ 
\end{bmatrix}
@
- 영상의 특정 좌표 값을 주변 픽셀들의 값의 산술평균 으로 설정하는 필터
- 영상이 부드러워지는 효과, 영상의 잡음 감소 효과
- 초점이 흐려지는 단점
- 모든 마스크의 값이 1, 결과 영상의 픽셀값은 입력영상에서 주변 픽셀들의 평균값을 가진다.
- 마스크의 크기가 클 수록 더욱 부드러운 영상 생성
- 중간에 가중치를 주어 실제 값을 더 살릴 수 있음

### Smoothing Linear Filters

@
g(x,y) = \frac{\sum\limits_ {s=-a}^{a} \sum\limits_ {s=-b}^{b} w(s,t) f(x+s, y+t)}{\sum\limits_ {s=-a}^{a} \sum\limits_ {s=-b}^{b} w(s,t)}
@

- Blurring 마스크는 모든 계수가 양수로 전체 합은 1
- 디지털 영상에서 세세한 부분은 화소 값이 극단적인 값에 속함. 이 극단적 값을 제거하는 방법이 평활화, 평균값으로 대체하는 것
  - 여기서 극단적이라는 의미는, 주변 값과 비교하였을 때 값이 급변하는 부분
- Blurring 마스크의 계수는 평균을 구하는 데 사용되므로 모두 값이 같음

![image](https://user-images.githubusercontent.com/32366711/164960468-68f1e2e0-06d1-4d12-8e37-0c8345602d05.png)

- 작은 객체는 배경과 합쳐지고, 큰 객체는 대표할 수 있게 하여, 관심 대상 객체의 대체적인 표현을 얻을 목적으로 영상을 흐리게 한다

![image](https://user-images.githubusercontent.com/32366711/164960479-09f7b384-ef04-44ae-9f63-3c34a37812eb.png)


#### Mean Filter

> 영상의 특정 좌표 값을 주변 픽셀들의 값의 산술 평균으로 설정하는 필터

- 모든 마스크의 값이 1이며, 결과영상의 픽셀값은 주변 픽셀들의 평균값을 가진다
- 영상이 부드러워지며, 영상의 잡음이 감소하는 효과가 있다
- 마스크의 크기가 클수록 더 부드러운 영상이 생성된다
- 단 초점이 흐려지는 단점이 있다

#### Weighted Mean Filter

- 평균 값 필터의 일종
- 필터 마스크의 가운데에 위치한 픽셀에 가중치를 더 주는 방법

#### OpenCV::blur()

~~~ c++
void cv::blur(
  InputArray src,  // Mat src
  OutputArray dst, // Mat dst
  Size ksize,      // kernel size, mask size
  Point anchor = Point(-1,-1), // center
  int dorderType = cv::BORDER_DEFAULT
)
~~~

### Gaussian Smoothing Filter

> 가우시안 분포를 영상 처리에 적용한 것으로      
> 정규 분포, 확률 분포에 의해 생성된 잡음을 제거하기 위한 필터

@
N(\mu, \sigma) = \frac{1}{\sigma\sqrt{2\pi}}exp(-\frac{(x-\mu)^2}{2\sigma^2})
@

- 스무딩 정도인 가우시안 분포 마스크의 폭은 표준편차가 파라미터로 작동한다
  - 표준편차가 클수록 더 큰 스무딩 효과를 가진다
- 가우시안 분포 함수는 단일 돌출(Single Peak)부분을 가진다
- 2차원 가우시안 분포 함수는 순환대칭 특징을 가진다
- 가우시안 분포 함수의 퓨리에 변환은 빈번한 스펙트럼상에 단일 돌출 부분을 가진다
  - 가우시안 퓨리에 변환 == 가우시안 분포
  - 공간 및 주파수 영역에 가우시안 분포 함수 적용 가능

#### 1차원 가우시안 분포

- 정규분포에서 평균을 0으로 하여 유도한 분포
@
G(x) = \frac{1}{\sqrt{2\pi}\sigma^2}e^{-\frac{x^2}{2\sigma^2}}
@

26p

- $\sigma$ 가 가우시안 분포의 폭 결정
  - $6\sigma$ 와 같거나 큰 가장 작은 홀수 사용
- $\sigma$ 값이 <red>클수록</red> 많은 <red>저주파</red> 성분을 통과시킴
- $\sigma$ 값이 <red>작을 수록</red> 적은 <red>고주파</dred> 성분만 통과 시킴
- 마스크의 크기가 너무 작으면 오차가 발생하고,
- 마스크의 크기가 너무 크면 계산 시간이 과다된다 (컨볼루젼 연산을 해야하기에)


#### 2차원 가우시안 분포

@
G(x,y) = \frac{1}{2\pi\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}}
@

37p

- 이산 공간에서 구현
- $\sigma=1.0$ 인 경우 : 6보다큰 정수 중, 가장 작은 홀수은 7을 적용하여 7*7 마스크 사용
- $\sigma=0.8$ : 5*5 마스크
- $\sigma=0.4$ : 3*3 마스크

- 모든 과학분야에서 가장 보편적인 분포
- 특정 값의 출현 비율을 그래프로 그렸을 때, 평균에서 가장 큰 수치 가짐
- 평균을 기준으로 좌우 대칭 형태
- 양끝으로 갈수록 수치가 낮아지는 종 모양
  - 평균과 표준 편차로 그래프 모양 변경

#### OpenCV::getGaussianKernel()

가우시안 커널 생성

~~~ c++
Mat cv:: getGaussianKernel(
  int ksize,
  double sigma,
  int ktype = CV_64F
)
~~~

#### OpenCV:: GaussianBlur()

사이즈를 주면 알아서 가우시안 커널을 만들어 블러링

~~~ c++
void cv::GaussianBlur(
  InputArray src,
  OutputArray dst,
  Size ksizem
  double sigmaXm
  double sigmaY = 0,
  int borderType = cv::BORDER_DEAFULT
)
~~~

## High-Pass Filter

> 중간고사 이후

> 신호 성분 중 고주파 성분은 통과시키고 저주파 성분은 차단

- 첨예화 또는 샤프닝(sharpening)
  - 샤프닝은 기존 영상에 경계만 진해지는데,
  - 하이패스 필터는 기존 이미지에 경계만 남고 검정색이 됨
- 마스크 계수의 합은 0이기 때문에 일정하거나 서서히 변하는 밝기 영역에서 마스크 응답을 0에 가깝게 함
-  마스크가 중앙의 큰 양수 값과 주위의 작은 음수 값으로 되어 경계선을 더욱 두드러지게 함

@
\frac{1}{9} \times \begin{bmatrix}
-1 & -1 & -1 \\\ 
-1 & 8 & -1 \\\ 
-1 & -1 & -1 \\\ 
\end{bmatrix}
@


# Noise Models

> 노이즈란, 입력신호 이외의 모든 전기 신호

인위적인 잡음을 영상에 첨가하여 잡음제거 알고리즘의 성능을 확인해 봄

사람의 실수, 자연계의 영향, 반도체의 특성 등등으로 잡음이 발생함

@
g(x,y) = f(x,y) + \eta(x,y)
@

## Median Filter

> 이웃과 차이가 큰 잡음이 있다면, 이웃 화소의 메디안을 취하여 차이를 줄여줌

@
f(x,y) = \underset{(s,t) \in s_ {xy}}{median} \, g(s,t) 
@

- 임펄스 잡음(솔트페퍼 잡음)에 효과적
- 엣지(경계선) 보존효과가 뛰어남. 엣지보존 스무딩 필터
- 주로 블록마스크가 효율이 좋고, 다이아몬드형 마스크를 가장 많이 쓴다

but
- 마스크의 크기가 클수록 정렬 알고리즘 수행시간이 길어진다
- 마스크 형태가 미디언 필터링에 영향을 미친다

1. 마스크 내의 영상 화소값을 추춘
2. 추출한 화소값을 정렬하여 중간값 추출
3. 추출한 중간값을 출력 영상의 화소로 출력

-> 정렬하는데 시간이 오래걸림

개선된 알고리즘
- Hybrid Median Filter 
- Separable Median Filter
- Recursive Median Filter
- Weighted Median Filter
- Multistage Median Filter


#### OpenCV::medianBlur()

~~~ c++
void cv::medianBlur(
  InputArray src,
  OutputArray dst,
  int ksize // ksize*ksize의 박스 마스크
)
~~~

### Hybrid Median Filter

> Median 필터는 Mean 필터보다는 덜하지만, 영상내의 직선, 코너와 같은 부분이 뭉퉁해질 수 있다          
> 이를 보완하여 잡음 제거, `경계선 보존`에 중점을 둔 알고리즘

1. 영상에서 홀수X홀수 영상의 마스크 추출
2. 추출한 마스크에서 대각선과 역 대각선 그룹을 얻는다.
3. 각 그룹을 정렬 한 후 그룹별 중간값을 추출한다.
4. 마스크의 중심값을 얻어 그룹별 중간값과 정렬한 후 중간값을 구한다.
5. 구한 중간값을 출력 영상의 화소에 삽입한다

- 가우시안 잡음의 제거는 한계가 있고, 경계선이 뚜렷하지 않다

### α-trimmed Mean Filter

> Mean 필터와 Median 필터의 장점을 갖춘 알고리즘

- $\alpha$ 값에 따라 Median 필터 혹은 Mean 필터로 동작한다
- $\alpha = 0.5$ : 미디언 필터링
- $\alpha = 0 ~ 0.4$ : 평균 필터링

@
\hat{f}(x,y) = \frac{1}{mn-d}\sum\limits_ {(s,t) \in S_ {xy}}^{} g_ r (s,y)
@

1. 마스크내의 화소값을 오름차순 정렬한다.
2. 마스크를 이루는 블록의 갯수와 α의 값(0.0 ~ 0.5)을 곱한 수(X)를 구한다.
3. 구해진 수 X의 소수점 이하를 버린다.(Trim)
4. Trim 하여 얻어진 정수 만큼 오름차순 정렬한 배열의 양쪽방을 제거한다.
5. α=0.5이면 미디언 필터링, α=0.0 ~ 0.4이면 평균 필터링과 같은 알고리즘으로 작동


## 컬러 영상의 컨볼루션

> 컬러 영상은 R, G, B 채널 3개를 이용해 다양한 색을 표현하므로 이 채널을 응용하여 컨볼루션 처리 수행             

`독립 채널별 컨볼루션 수행`과 `HSI 컬러 모델로 변경한 뒤 컨볼루션`을 처리하는 두 가지 방법이 있음        

### 독립 채널별 컨볼루션

> RGB 컬러 영상을 R, G, B 채널로 분리하여 채널별로 각각 컨볼루션을 수행한 뒤 컨볼루션 처리된 각 채널을 다시 조합해서 컨볼루션 된 컬러 영상 생성

but, RGB 컬러 영상은 채널 3개를 조합해서 색을 표현하므로 컨볼루션 과정에서 아주 작은 오류만 발생해도 조합된 컨볼루션에서 정확한 결과를 만들지 못함


### HSI 컬러 모델로 변경한 뒤 컨볼루션

> 밝기 성분인 `명도(I)` 부분만 컨볼루션 처리를 수행하고 나머지 두 성분은 수행하지 않음. 마지막으로 HSI는 다시 RGB 컬러 영상으로 변환됨. 

색상(H)에서 컨볼루션 처리를 하지 않아 원 영상의 색상 부분이 그대로 보존되므로 독립 채널별로 컨볼루션 처리하는 방법보다 더 정확
