---
layout: post
title: "BD, L4. MongoDB Query"
description: "빅데이터 시스템 디자인, 아지즈교수님"
categories: [BigDataSystemDesign]
tags: [2022-1, Big Data System Design, BD, 아지즈]
use_math: true
redirect_from:
  - /2022/03/22
---

* Kramdown table of contents
{:toc .toc} 

# MongoDB Components

12p 이미지
15p 이미지

# MongoDB Components

## Database

- `use DATABASE_NAME` : If the database already exists, it will return the existing database, else if database dosent exists, it will make database and return
- `db` : check selected database
- `show dbs` : check your databases list, 데이터를 아무것도 안넣으면 아직 empty, 그래서 show에서 나오지 않음
- `dp.dropDatabase()` : 현재 DB 삭제

## Collection

- `db.COLLECTION_NAME.drop()` : 현재 Collection 삭제
- `db.createCollection("name", {options})`[^options]
- `db.COLLECTION_NAME.drop()` : Collection 삭제
- `show collectios` : 현재 Database의 collection list 출력
- `db.COLLECTION_NAME.insert(\[{document}\])` : collection 이 생성되어있지 않더라도 document를 입력하면, collection이 자동으로 생성됨
- `db.COLLECTION_NAME.isCapped()`
- `db.runCommand({"converToCapped":"COLLECTION_NAME", size:10000})`


[^options] : {capped[^capped] : Boolean, size[^size] : number, max[^max] : number}
[^capped] : 고정된 사이즈를 가지게 됨. capped가 true면 size or max를 정해줘야함. 
[^size] : capped collection의 최대 `byte`를 정해줌
[^max] : capped collection의 `douments의 최대 갯수`를 정해줌


## Document 

- `db.COLLECTION_NAME.insert(document)` : document is {key: value}
- `db.COLLECTION_NAME.insertOne(document)`
- `db.COLLECTION_NAME.insertMany(array)`
- `db.COLLECTION_NAME.find(query, projection)` : select all documents, SELECT * FROM COLLECTION_NAME
  - `db.COLLECTION_NAME.find().pretty()` : print formatted

# Find 

db.COLLECTION_NAME.find(query, projection)

expression = {field : {operator: value}}

- `$eq` : $=$
- `$ne` : $\neq$
- `$gt` : $>$ 
- `$gte` : $\geq$
- `$lt` : $<$
- `$lte` : $\leq$
- `$in` : $\in$, value = array
- `$nin` : $\notin$, value = array

expression = {operator: \[expression, expression \]}

- `$and`
- `$not`
- `$nor`
- `$or`

## Dot notation

embedded document 쿼리는 Dot notation으로 해야함.

그냥 document로 넣으면 완벽히 같은 document를 찾아와서 비

## Projection

db.COLLECTION_NAME.find(query, {field : 0/1})

- 0만 있으면 해당 필드 제외하고 모든 벨류가 보임
- 1만 있으면 해당 필드만 보임

# Update

`db.COLLECTION_NAME.update(query, updated_document)`

db.inventory.update({item: "paper"}, {$set: {item: "paperless"}})

-> 맨 처음 document만 바뀜

db.inventory.update({item: "paper"}, {$set: {item: "paperless"}}, {multi: true})

# Delete

`db.COLLECTION_NAME.remove(query)`

query가 빈 괄호, {}면 모든 document 삭제

`db.COLLECTION_NAME.remove(query, 1)` : 맨처음 1개 데이터만 삭제, justOne

# Element

{field : null}    
{field : {$ne : null}}  
{field : {$exists : false}}
{field : {$exists : true}}


- `$exists`
- `$type` : BSON type

# Regular

- `$expr` 
  - ^text : start
  - text$ : end 
  - {$regex: "text", $options: 'i'} : 대소문자 무시
- `$jsonSchema`
- `$mod`
- `$regex`
- `$text`
- `$where`

# Aggregation

`db.COLLECTION_NAME.aggregate(pipeline, options)`

~~~

db.collection.aggregate([
  {$unwind},  // stage
  {$match},
  {$group},
  {project},
  {$sort},
  {$limit}
])

~~~

|:---:|:---:|
|WHERE | $match|
|GROUP BY | $group |
|HAVING | $match|
|SELECT | $project|
|ORDER BY | $sort|
|LIMIT | $limit|
|SUM() | $sum |
|COUNT() | $sum , sortByCount |