---
layout: post
title: "SE, 7장 Software Design"
description: "SE, 홍장의 교수님"
categories: [Software_Engineering]
tags: [2021-2, SE, Software Engineering, 홍장의]
use_math: true
redirect_from:
  - /2021/11/08/
---

* Kramdown table of contents
{:toc .toc}    


# Design

소프트웨어 형태로 표현을 바꿔주는 것

Why Important, what is imortant

퀄리티(품질)강화되는 단계

소프트웨어의 퀄리티를 평가하는 단계

좋은 설계라는 것은

계층적 구조, 모듈적, 분할/구분되어 표현, 모듈(독립적 기능), 인터페이스 복잡도가 감소, 수정에 용이

모듈간에 인터페이스가 복잡하다 = 메세지 교환이 많다, 펑션콜이 많다.


모듈러리티가 높다, 개발비용이 높다, 유지보수비용이 낮다

각가그이 모듈이 기능적으로 독립성을 가지고 잇을 때, 모듈을 잘했따

모듈화되었다라는 것은 원리중에 추상화, 정보은닉과 관련되어있다

커플링 : 모듈 외적 관계
코헤젼 : 모델 내적 관계


# Modularity

## Coupling

외부 상호작용, 최대한 낮게

> 두개의 모듈 사이의 상호의존성 정도

`낮아야 한다`

모듈간의 상호작용이 적으니까 모듈 하나만 보고도 뭘 하는 모듈인지 쉽게 이해할 수 있다

유지보수를 잘 하려고한다. 
이후 수정할때 파급효과를 최소화 해야한다.

모듈간의 상호작용이 많으면 수정해야하는 부분이 많아진다

미니마이즈하기위해선 어떻게 해야하는가
불필요한 관계는 제거한다
필요한 관계도 최소한으로 줄여라

## Cohesion

내부 상호작용, 최대한 높게
관련성 있는 것들을 잘 모아놓아야 함
Data Coupling -> Stamp Coupling -> Control Coupling -> Common Coupling -> Contents Coupling

### Message Coupling

객체지향의메세지패싱은 정보은닉, 캡슐화라는 특징이 있다

정보은닉은 뭐냐, 필요한거만 공개하고 나머진 감춘다. 모듈간의 상호작용엣 꼭 필요한거만 공개ㅏ겠다

가장 좋은 방법

퍼블릭 인터페이스만으로 상호작용하겠다

### Data Coupling

두개으 ㅣ모듈이 존재할 때 함수호출을 할건데, 객체지향은 함사룰 하나의 메세지로 관리하는데, 일반적인소프트웨어모듈은 펑션콜을하려면 파라미터, 데이터를 보내야 한다

아주 기초 데이터 int char 등등
만으로 파라미터를 패싱한다

#### Warnings on Data Coupling

WIDE 

너무 많다. 파라미터갯수가 너무 많으면 더 복잡해지고, 이해하기 어려워 질 수 있다

미스매칭 등

만약에 많아지게 된다면, 구조체 등을 선언해서 쓰는게 좋다

TRAMP DATA - 불필요한데이터

단독변수로 보낼때는 보내고싶은데이터만 보낼 수있다

구조체로할경우에는, 굳이 안보내도 되는 데이터도 보내야한다

재구조화가 필요하다

### Stamp Coupling

구조체 등 Composite data type을 전달하는 것

#### Warnings on Stamp Coupling

항목들간에 성격이 다르면, 구조체 네이밍하기 어려움
구조체가 무슨능력을하는지 의미를 특정하기 어려움. 모호성 증가
그러면 유지보수능력이 떨어짐

### Control Coupling

이후로는 그닥 좋진 않음

> 다른 모듈을 제어할 의미를 가지고 메세지를 넘기는 것

컨트롤의 방향
포워드 : 호출이 피호출 모듈을 제어
-> Split
배워드(inversion of authority) : 피호출이 리턴으로 호출 모듈을 제어
-> Write 이런거말고 그냥 NOne값같은거 넘겨주면 됨

| Type | Type of name | 
|:-----:|:-----------:|
| Control flag | Verb |
| Descriptive flag | Adjective |

### External Coupling

외부 디바이스에 계속 접촉하면 부하가걸리니까
각각 쪼개서 나눠갖는것도 한 방법

### Common Coupling

전역변수를 두고 두 모듈을 제어하겠다는
많이하지만, 데이터를 주고받고 할 때에는
싱크가 잘 맞아야 한다

Ripple Effect 파급 효과
전역변수를 하나 수정했을때, 모든 모듈을 점검해야할 필요성이 생김

유연함이 떨어짐

remoteness time이 떨어진다

공유변수 하나를 굉장히 다양하게 쓴다. 남용

#### module scoped variables

### Content Coupling

모듈의 내용을 직접 언급

goto
Assemply

## Cohesion

커플링이 낮다고 응집력이 높진않음
반대는? 가능할수도있음
`응집력이 높으면 커플링이 낮을 수 있다`

### Functional Cohesion

> 딱 한가지 목적으로만 짜여져 있다. 기능이 있다

일반적으로 하나의 모듈 안에 관련성 높은것만으로 짤것이다라고 생각

기능 응집력이 높은건 클래스

멤버 변수와 멤버 함수가 필요한것들로 잘 이루어져있다


### Sequential Cohesion

> 순서대로 진행

기능응집력도 순차응집력을 가지면 좋다

꼭 애플리케이션 도메인에 대응되지 않을수도 있다.

단지 지나가는 역할일 수도 있다

재사용 관점에서는 좀 떨어질 수 있다

### Communicational Cohesion

교환 응집력

같은 input, output을 쓸 때는, 교환응집력이 있다고 할 수있다

#### Warinigs on Communicational Cohesion

재사용이 낮다

리턴벨류의 부분만 쓰려고 할 때, 그럼?

쪼갠다 나눠서 쓴다

만약 상위 20프로 등 부분만 알려고 할때도 쓸 수 없음

각각의 모듈이 독립적인 일을 할 수 있도록 쪼갤 필요가 있다

### Procedural Cohesion

절차 응집력

관련이 적은 활동인데, 순차적으로 수행 가능한 것

필요 없는건 삭제

### Temporal Cohesion

시간 응집력

그 시간대에, 특정 시점에 발생횔 수 있는 일드를 모아서 모듈을 만드는데,

프로그램 시작시점, 종료시점에 몰아넣었다 == 안좋음

그때그때

모든걸 다 할 수 있는 모듈이 아닌, 그때그때 할수있는 모듈

### Loical Cohesion

논리적 응집력


# Object Oriented Design

최종 수정단계

분석 모델이 오류가 없어야 설계가 원활히 진행될 수 있음

3가지관점

펙토링, 패턴을 통해서 더 나은 모습으로 바꾼다

가시성, public, prevate ..

제약사항은 없는지, 함수원형은 어떤지

이 메소드가 내부적으로는 어떻게 동작하는지

클래슫 아이어그램을 클러스터링한다
같은 역할을 하는 다이어그램을 묶어서
패키지로 만든다
패키지 다이어그램

이 패키지 다잉그램을 레이어드 패키지 다이어그램으로 만든다
ㅠ사용자 인터페이스 ,PD 문제 영역, DM 데이터 메뉴플레이션


## Class & Method Desgin

추가적인 명세

다음의 4가지를 할 수 있다

1. 클래스가 요구사항에 대해서 충분한가?
2. 

틀래스에서 + - / 를 넣을 수 있는데
- priv, + public / 임시변수

기타 제약사항들도 정의함

Normalization, m:n 관계를 1:m m:1로 쪼갤필요도 있음

변수별로 inveriant를 정해줄수있다

각 메소드에 대해서

Method Specification을 작성해야한다

Pre COndition 전제조건, 함수실행을 위한 조건


## Architenture Design

점선 : 의존성, 디펜던시 관계
A is dependent B, A는 B에 의존적이다

B가 수정되면 A도 수정되어야 한다



## Layering Design

## Physical Architecturing
