---
layout: post
title: "SE, 7장 Software Design"
description: "SE, 홍장의 교수님"
categories: [Software_Engineering]
tags: [2021-2, SE, Software Engineering, 홍장의]
use_math: true
redirect_from:
  - /2021/11/08/
---

* Kramdown table of contents
{:toc .toc}    


# Design

> 요구사항을 소프트웨어 표현 형태로 바꿔주는 것
> 퀄리티(품질)가 강화되는 단계

`소프트웨어의 퀄리티를 평가하는 단계`

좋은 설계라는 것은         
- 계층적 구조
- 모듈적(독립적 기능)
- 데이터와 Procedure이 분할, 구분되어 표현
- 인터페이스 복잡도가 적어야함
- 수정에 용이해야 함

모듈러리티가 높다, 개발비용이 높다, 유지보수비용이 낮다

각각의 모듈이 기능적으로 독립성을 가지고 잇을 때, 모듈화를 잘했다

모듈화되었다라는 것은 원리중에 추상화, 정보은닉과 관련되어있다

Coupling, 결합력 : 모듈 외적 관계
Cohesion, 응집력 : 모델 내적 관계


# Modularity

![image](https://user-images.githubusercontent.com/32366711/142660987-6520babb-3648-4bfe-8c6c-c236f4733c55.png)

## Coupling

> 두개의 모듈 사이의 상호의존성 정도      
> 외부 상호작용, <red>최대한 낮아야 한다</red>    

모듈간의 상호작용이 적으면 모듈 하나만 보고도 뭘 하는 모듈인지 쉽게 이해할 수 있다         

- 유지보수를 잘 하려고한다.       
  - 이후 수정할때 파급효과를 최소화 해야한다.           
  - 모듈간의 상호작용이 많으면 수정해야하는 부분이 많아진다

- 미니마이즈하기위해선 어떻게 해야하는가
  - 불필요한 관계는 제거한다
  - 필요한 관계도 최소한으로 줄여라

Message Coupling              
-> Data Coupling 
-> Stamp Coupling 
-> Control Coupling           
-> External Coupling
-> Common Coupling              
-> Contents Coupling            

### Message Coupling

> 가장 좋은 방법  
> 객체에서와 같이 상태 분산화를 통해 달성할 수 있으며,  
> 구성요소 통신은 매개 변수 또는 메시지 전달을 통해 수행된다

모듈이 서로 의존하지 않고, 공개 인터페이스를 사용하여 매개 변수 업는 메시지를 교환한다

객체지향의 메세지 패싱은 정보은닉, 캡슐화 특징이 있다

정보은닉 : 필요한거만 공개하고 나머진 감춘다. 
모듈간의 상호작용엣 꼭 필요한거만 공개하겠다

퍼블릭 인터페이스만으로 상호작용하겠다

### Data Coupling

> 두 모듈은 매개 변수에 의해 통신하는 경우 데이터 커플링이라 하며,     
> 각 매개 변수는 기본 데이터 타입(int, char, float 등등)이다

데이터를 교환하는건 불가피하며, 최소로 유지하는 한 매우 무해하다

두개의 모듈이 존재할 때 함수호출을 할건데, 객체지향은 함사룰 하나의 메세지로 관리하는데, 일반적인소프트웨어모듈은 펑션콜을하려면 파라미터, 데이터를 보내야 한다

#### Warnings on Data Coupling

- Avoid WIDE interface 
  - 파라미터는 가능한 적어야 한다
  - 파라미터갯수가 너무 많으면 더 복잡해지고, 이해하기 어려워 질 수 있다
  - 만약에 많아지게 된다면, 구조체 등을 선언해서 쓰는게 좋다

- Avoid TRAMP DATA - 불필요한데이터
  - 단독변수로 보낼때는 보내고싶은데이터만 보낼 수 있다
  - 구조체로할경우에는, 굳이 안보내도 되는 데이터도 보내야한다
  - 재구조화가 필요하다

### Stamp Coupling

> 매개변수가 구조체등 합성 변수(Composite data type)로 이루어져 있다        
> 데이터 구조가 애플리케이션에 고유하고 불필요한 모호함이 없는 경우에만 스탬프 결합 모듈이 괜찮음

#### Warnings on Stamp Coupling

항목들간에 성격이 다르면, 구조체 네이밍하기 어려움   
== 구조체가 무슨능력을하는지 의미를 특정하기 어려움. 모호성 증가
== 유지보수능력이 떨어짐

### Control Coupling

> 모듈이 다른 모듈을 제어하기 위해 메세지를 넘기는 것

- 컨트롤의 방향
  - 포워드 : 호출이 피호출 모듈을 제어  -> Split
  - 백 워드(inversion of authority) : 피호출이 리턴으로 호출 모듈을 제어
-> Write 이런거말고 그냥 None값같은거 넘겨주면 됨

#### 포워드

flag 변수를 넘겨줘서 피호출 모듈에서 if문으로 각기 다른 내용을 수행하게 되는 경우

이럴땐 그냥 각기 다른 함수 2개를 만들어서 따로 호출할 수 있게 해야함

#### 백워드

컨트롤 플래그 대신 디스크립티브 플래그 사용

| Type | Type of name | Examples |
|:-----:|:-----------:|:--------:|
| Control flag | Verb | Read next record
| Descriptive flag | Adjective | Egg is rotten |

### External Coupling

두개의 모듈이 외부 자원을 공유하는 것

외부 디바이스에 계속 접촉하면 부하가 걸리니까
각각 쪼개서 나눠갖는것도 한 방법

### Common Coupling

두 묘듈이 같은 전역변수를 공유하게 되는 것

-Ripple Effect 파급 효과
  - 전역변수를 하나 수정했을때, 모든 모듈을 점검해야할 필요성이 생김
- 모듈의 유연성 감소
- remoteness time이 떨어진다
- 공유변수 하나를 굉장히 다양하게 쓴다. 남용 간으성

#### Recommendation

- 중요한 전역변수는 매개변수화 한다
- 모듈을 쪼개어, 전역 변수의 사용 범위를 정의한다
- access functions(get, set 함수)를 통해 전역변수를 제어한다

### Content Coupling

한 모듈에서 다른 모듈 내용을 직접 언급

goto
Assemly


## Cohesion

내부 상호작용, 최대한 높게
관련성 있는 것들을 잘 모아놓아야 함

커플링이 낮다고 응집력이 높진않음

그러나 `응집력이 높으면 커플링이 낮을 수 있다`

- Functional
- Sequential
- Communicational

- Procedural
- Temporal
- Logical
- Coincidental

### Functional Cohesion

> 모듈이 딱 한가지 목적, 기능으로만 짜여져 있다

일반적으로 하나의 모듈 안에 관련성 높은것만으로 짤 것이다라고 생각

기능 응집력이 높은건 클래스

멤버 변수와 멤버 함수가 필요한것들로 잘 이루어져있다


### Sequential Cohesion

> 순서대로 진행되는 모듈

- Clean Car Body;
- Fill in Boles in Car;
- Sand Car Body;
- Apply Primer;

기능 응집력도 순차 응집력을 가지면 좋다

기능 응집력이 있는 모듈은 어플리케이션 영역의 어떤 개념(도메인)에 해당될 수 있지만, 순차 응집력이 있는 모듈은 해당되지 않는다

단지 지나가는 역할일 수도 있다

유지보수 측면에서는 대체로 좋다. 그러나 기능적 응집력보다 재사용성이 떨어진다


### Communicational Cohesion

> 동일한 입력 또는 출력 데이터를 사용하는 활동에 기여하는 모듈

같은 input, output을 쓸 때는, 교환응집력이 있다고 할 수있다

실행 순서는 중요하지 않음

#### Warinigs on Communicational Cohesion

호출자가 반환 값 부분에 관심이 있는 경우, 불필요한 데이터와 필요한 데이터를 찾기 위한 코드가 따로 필요하게 된다
- dirty and redundant coupling + duplication of function

-> 각 반환 요소에 대해 기능적 응집력 모듈을 만든다

각각의 모듈이 독립적인 일을 할 수 있도록 쪼갤 필요가 있다

### Procedural Cohesion

> 관련이 적은 활동이지만, 순차적으로 수행 가능한 것들도 모아 놓은 것

필요 없는 것, 다른 주제의 내용들은 삭제
-> 기능적, 순차적 응집력

### Temporal Cohesion

> 그 시간대에, 특정 시점에 발생횔 수 있는 일들을 모아서 모듈을 만든 것

선언은 프로그램 시작시점에, 메모리 해제는 종료시점에 몰아넣었다 == 안좋음


### Loical Cohesion

> 실행할 활동이 모듈 외부에서 선택되는 동일한 일반 범주의 활동에 기여하는 요소

동일한 일반 활동을 여러개 포함하며, 이들이 플래그에 의해 실행됨

기능적 응집력을 가진 모듈 여러개로 분리하는것이 필요

### Concidental Cohesion

> 요소들이 서로 의미 있는 관계가 없는 활동에 기여하는 모듈

모듈의 일부분은 소스코드에서의 위치만 관련이 있다

기능을 수행하는데 필요한 요소는 시스템 전체에 흩어져 있음

`최악`

# Object Oriented Design

최종 수정단계

분석 모델이 오류가 없어야 설계가 원활히 진행될 수 있음

3가지관점

펙토링, 패턴을 통해서 더 나은 모습으로 바꾼다

가시성, public, prevate ..

제약사항은 없는지, 함수원형은 어떤지

이 메소드가 내부적으로는 어떻게 동작하는지

클래슫 아이어그램을 클러스터링한다
같은 역할을 하는 다이어그램을 묶어서
패키지로 만든다
패키지 다이어그램

이 패키지 다잉그램을 레이어드 패키지 다이어그램으로 만든다
ㅠ사용자 인터페이스 ,PD 문제 영역, DM 데이터 메뉴플레이션


## Class & Method Desgin

추가적인 명세

다음의 4가지를 할 수 있다

1. 클래스가 요구사항에 대해서 충분한가?
2. 

틀래스에서 + - / 를 넣을 수 있는데
- priv, + public / 임시변수

기타 제약사항들도 정의함

Normalization, m:n 관계를 1:m m:1로 쪼갤필요도 있음

변수별로 inveriant를 정해줄수있다

각 메소드에 대해서

Method Specification을 작성해야한다

Pre COndition 전제조건, 함수실행을 위한 조건


## Architenture Design

점선 : 의존성, 디펜던시 관계
A is dependent B, A는 B에 의존적이다

B가 수정되면 A도 수정되어야 한다



## Layering Design


보험에 관련된 캐리어가 누구냐
아들은 아버지에게 종속되어있다

Secondary Key
0 / * 인쪽에다가

다대다일 경우에는 새로운 클래스를 하나 생성

## 사용자 인터페이스

사용자가 시스템을 사용할 유즈 시나리오를 고민해야한다

어떠한 패턴을 통해서 시스템 패턴을 사용할 것이다
이때 이 유즈시나리오는 유즈케이스의 스텝들
모든 가능한 시나리오는 생성불가능
메이저위주로 생성

사용자가 어떤 경로를 만들 수 있는가 : 윈도우 네비게이션 다이어그램
UI 메뉴 구성


## Physical Architecturing


## Design Patterns

- Preliminary design
    - transformation of requirements into data and software architecture.
- Detailed design
    - refinements to the architectural representation that lead to detailed data structure and algorithmic representations for software
    
### GoF Design Patterns[^GoF]

> Gang of Four

설계자들간의 의사 소통의 수단
어플리케이션 의존적인 부분의 분리 : 확장성 증대
기존 모델의 품질 향상
클래스를 확장하지만 코드는 변경으로부터 감춤 : 쉽게 더 추가할 수 있는 방법은 무었일까


[^GoF]: Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides가 제안

### Application of Design Patterns

타입바인딩

상속받는 서브 클래스에서 재정의하지말고, 일단 상속해서, 다른 클래스를 만들어서 합성해라

### 생성 패턴, Creational Patterns

### 구조 패턴, Structural Patterns

#### Composite

합성되어 있다

단순한 객체가 모여 만들어진 복합 객체

서브디렉토리에는 파일과 또 디렉토리가 존재할 수 있다

#### Adapter

호환성이 없는 객체들, 인터페이스가 없는 객체들을 사용하려고 할 때 중간에서 맞춰주는 역할

- 상속, 클래스 어댑터 패턴
- 위임, 인스턴스 어댑터 패턴

adapter 클래스를 잘 만들어서 여러 adaptee를 잘 써보자

#### Decorator

기존에 구현되어 있는 클래스에 그때그때 필요한 기능을 추가해 나가는 설계패턴
기능확장이 필요할 때 상속의 대안으로 사용

#### Facade

클라이언트 - 서버에서 클라이언트가 여러개를 관리해야 할 때
facade 클래스를 만들어서 메인은 facade만 사용하고, facade에서 하위 클래스들을 모두 관리

#### Proxy

대신 처리, 시간이 오래걸리는 일 들

### 행위 패턴, Behavioral Patterns

#### Iterator

> 반복이 필요한 자료구조를 모두 동일한 인터페이스를 통해 접근

- 반복에 사용되는 자료구조
    - 배열, 리스트, Set, Map 등
- 데이터들의 집합체를 모두 동일한 인터페이스를 사용하여 조작 할 수 있게하는 것

#### Observer

> 어떤 클래스에 변화가 일어났을 때, 이를 감지하여 다른 클래스에 통보해주는 것

어떤 일이 생기면 미리 등록한 객체들에게 상태 변화를 알려주는 역할

#### Strategy

> 클라이언트에게 알고리즘이 사용하는 데이터나 그 구조를 숨겨주는 역할

- 알고리즘 군을 정의하고 같은 알고리즘을 각각 하나의 클래스로 캡슐화한 다음, 필요할 때 서로 교환해서 사용할 수 있게 함
- 알고리즘을 사용하는 곳과 알고리즘을 제공하는 곳을 분리시킨 구조로 알고리즘을 동적으로 교체 할 수 있음

솔트 알고리즘을 매번 지정해주는게 아니라
다양한 클래스르 구현하는거를 stratgeSort에 놓고 sort만 하면 알아서 판단해서 뭘 사용할지 정함

#### Template Method

#### Chain of Responsibility

#### Mediator

#### Memento
